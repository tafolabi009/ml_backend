package websocket
package websocket

import (
















































































































































































































































































}	return 0	}		return len(userClients)	if userClients, ok := h.clients[userID]; ok {	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) GetUserConnections(userID string) int {// GetUserConnections returns number of connections for a user}	return len(h.clients)	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) GetConnectedUsers() int {// GetConnectedUsers returns number of connected users}	return time.Now().Format("20060102150405.000000")func generateID() string {// generateID generates a unique connection ID}	}		}			}				return			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))		case <-ticker.C:			}				return			if err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {			}				return				c.conn.WriteMessage(websocket.CloseMessage, []byte{})			if !ok {			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))		case message, ok := <-c.send:		select {	for {	}()		c.conn.Close()		ticker.Stop()	defer func() {	ticker := time.NewTicker(54 * time.Second)func (c *Client) writePump() {// writePump writes messages to the websocket connection}	}		}			}				c.send <- []byte(`{"type":"pong"}`)			if msgType, ok := msg["type"].(string); ok && msgType == "ping" {		if err := json.Unmarshal(message, &msg); err == nil {		var msg map[string]interface{}		// Handle incoming messages (ping, subscribe, etc.)		}			break			}				log.Printf("WebSocket error: %v", err)			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {		if err != nil {		_, message, err := c.conn.ReadMessage()	for {	})		return nil		c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))	c.conn.SetPongHandler(func(string) error {	c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))	}()		c.conn.Close()		c.hub.unregister <- c	defer func() {func (c *Client) readPump() {// readPump reads messages from the websocket connection}	})		client.readPump()		go client.writePump()		// Start goroutines		h.register <- client		// Register client		}			id:     generateID(),			userID: userID,			send:   make(chan []byte, 256),			conn:   c,			hub:    h,		client := &Client{		// Create client		}			return			c.Close()			log.Println("WebSocket connection rejected: no user_id")		if userID == "" {		}			}				userID = uid.(string)			if uid := c.Locals("user_id"); uid != nil {		if userID == "" {		userID := c.Query("user_id")		// Get user ID from query or locals	return websocket.New(func(c *websocket.Conn) {func (h *Hub) HandleWebSocket() fiber.Handler {// HandleWebSocket handles WebSocket connection upgrade}	return data	}		return []byte("{}")		log.Printf("Error marshaling message: %v", err)	if err != nil {	data, err := json.Marshal(message)func (h *Hub) marshalMessage(message *Message) []byte {// marshalMessage converts message to JSON}	})		Data:   data,		JobID:  validationID,		UserID: userID,		Type:   "validation_update",	h.Broadcast(&Message{func (h *Hub) BroadcastValidationUpdate(userID, validationID string, data map[string]interface{}) {// BroadcastValidationUpdate broadcasts validation completion}	})		Data:   data,		JobID:  jobID,		UserID: userID,		Type:   "job_progress",	h.Broadcast(&Message{	data["status"] = status	data["progress"] = progress	}		data = make(map[string]interface{})	if data == nil {func (h *Hub) BroadcastJobProgress(userID, jobID string, progress float32, status string, data map[string]interface{}) {// BroadcastJobProgress broadcasts job progress update}	h.broadcast <- message	message.Timestamp = time.Now()func (h *Hub) Broadcast(message *Message) {// Broadcast sends a message to user(s)}	}		}			h.mu.RUnlock()			}				}					}						}							close(client.send)						default:						case client.send <- h.marshalMessage(message):						select {					for _, client := range userClients {				for _, userClients := range h.clients {				// Broadcast to all			} else {				}					}						}							delete(userClients, client.id)							close(client.send)						default:						case client.send <- h.marshalMessage(message):						select {					for _, client := range userClients {				if userClients, ok := h.clients[message.UserID]; ok {			if message.UserID != "" {			// Broadcast to specific user or all users			h.mu.RLock()		case message := <-h.broadcast:			log.Printf("WebSocket client unregistered: user=%s, conn=%s", client.userID, client.id)			h.mu.Unlock()			}				}					}						delete(h.clients, client.userID)					if len(userClients) == 0 {					close(client.send)					delete(userClients, client.id)				if _, ok := userClients[client.id]; ok {			if userClients, ok := h.clients[client.userID]; ok {			h.mu.Lock()		case client := <-h.unregister:			log.Printf("WebSocket client registered: user=%s, conn=%s", client.userID, client.id)			h.mu.Unlock()			h.clients[client.userID][client.id] = client			}				h.clients[client.userID] = make(map[string]*Client)			if _, ok := h.clients[client.userID]; !ok {			h.mu.Lock()		case client := <-h.register:			return		case <-ctx.Done():		select {	for {func (h *Hub) Run(ctx context.Context) {// Run starts the hub's main loop}	}		unregister: make(chan *Client),		register:   make(chan *Client),		broadcast:  make(chan *Message, 256),		clients:    make(map[string]map[string]*Client),	return &Hub{func NewHub() *Hub {// NewHub creates a new WebSocket hub}	Timestamp time.Time              `json:"timestamp"`	Data      map[string]interface{} `json:"data"`	JobID     string                 `json:"job_id,omitempty"`	UserID    string                 `json:"user_id,omitempty"`	Type      string                 `json:"type"`type Message struct {// Message represents a websocket message}	id     string	userID string	send   chan []byte	conn   *websocket.Conn	hub    *Hubtype Client struct {// Client represents a websocket connection}	unregister chan *Client	register   chan *Client	// Register/Unregister channels	broadcast chan *Message	// Broadcast channel	mu      sync.RWMutex	clients map[string]map[string]*Client	// Registered clients (map[userID]map[connectionID]*Client)type Hub struct {// Hub maintains active websocket connections and broadcasts messages)	"github.com/gofiber/websocket/v2"	"github.com/gofiber/fiber/v2"	"time"	"sync"	"log"	"encoding/json"	"context"