package circuitbreaker
package circuitbreaker

import (
	"context"
	"fmt"
	"time"







































































































}	return cb.cb.Counts()func (cb *CircuitBreaker) Counts() gobreaker.Counts {// Counts returns the current counts}	return cb.cb.State()func (cb *CircuitBreaker) State() gobreaker.State {// State returns the current state of the circuit breaker}	return result, err	}		}			return nil, fmt.Errorf("service unavailable: too many requests")			)				zap.String("circuit", cb.name),			cb.logger.Warn("Circuit breaker: too many requests",		if err == gobreaker.ErrTooManyRequests {		}			return nil, fmt.Errorf("service unavailable: circuit breaker open")			)				zap.String("circuit", cb.name),			cb.logger.Warn("Circuit breaker is open",		if err == gobreaker.ErrOpenState {	if err != nil {	})		return fn()				}		default:			return nil, ctx.Err()		case <-ctx.Done():		select {		// Check context cancellation	result, err := cb.cb.Execute(func() (interface{}, error) {func (cb *CircuitBreaker) Execute(ctx context.Context, fn func() (interface{}, error)) (interface{}, error) {// Execute executes a function with circuit breaker protection}	}		name:   config.Name,		logger: logger,		cb:     gobreaker.NewCircuitBreaker(settings),	return &CircuitBreaker{	}		},			}				config.OnStateChange(name, from, to)			if config.OnStateChange != nil {			)				zap.String("to", to.String()),				zap.String("from", from.String()),				zap.String("circuit", name),			logger.Warn("Circuit breaker state changed",		OnStateChange: func(name string, from gobreaker.State, to gobreaker.State) {		ReadyToTrip: config.ReadyToTrip,		Timeout:     config.Timeout,		Interval:    config.Interval,		MaxRequests: config.MaxRequests,		Name:        config.Name,	settings := gobreaker.Settings{func NewCircuitBreaker(config Config, logger *zap.Logger) *CircuitBreaker {// NewCircuitBreaker creates a new circuit breaker}	}		},			return counts.Requests >= 3 && failureRatio >= 0.6			failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)		ReadyToTrip: func(counts gobreaker.Counts) bool {		Timeout:     time.Second * 60,		Interval:    time.Second * 10,		MaxRequests: 3,		Name:        name,	return Config{func DefaultConfig(name string) Config {// DefaultConfig returns default circuit breaker configuration}	OnStateChange func(name string, from gobreaker.State, to gobreaker.State)	ReadyToTrip   func(counts gobreaker.Counts) bool	Timeout       time.Duration	Interval      time.Duration	MaxRequests   uint32	Name          stringtype Config struct {// Config for circuit breaker}	name   string	logger *zap.Logger	cb     *gobreaker.CircuitBreakertype CircuitBreaker struct {// CircuitBreaker wraps gobreaker with logging)	"go.uber.org/zap"	"github.com/sony/gobreaker"