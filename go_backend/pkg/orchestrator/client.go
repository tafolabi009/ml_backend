package orchestrator




















































































































































































































































}	return nil	}		return c.conn.Close()	if c.conn != nil {	}		return c.client.Close()	if c.client != nil {func (c *GRPCClient) Close() error {// Close closes the gRPC connection}	return &GRPCClient{conn: conn}, nil	}		return nil, fmt.Errorf("failed to create gRPC connection: %w", err)	if err != nil {	)		),			grpc.MaxCallSendMsgSize(100*1024*1024),			grpc.MaxCallRecvMsgSize(100*1024*1024),		grpc.WithDefaultCallOptions(		grpc.WithTransportCredentials(insecure.NewCredentials()),		addr,	conn, err := grpc.NewClient(	// Fall back to actual gRPC if needed	}		return &GRPCClient{client: client}, nil	if err == nil {	client, err := NewClient(addr)	// Try HTTP first	// For backward compatibility, we support both gRPC and HTTPfunc NewGRPCClient(addr string) (*GRPCClient, error) {// NewGRPCClient creates a gRPC client that wraps the REST client}	client *Client	conn   *grpc.ClientConntype GRPCClient struct {// Legacy gRPC client wrapper for backward compatibility}	TotalJobsToday   int     `json:"total_jobs_today"`	GPUInUse         int     `json:"gpu_in_use"`	GPUAvailable     int     `json:"gpu_available"`	MemoryUsage      float64 `json:"memory_usage"`	CPUUsage         float64 `json:"cpu_usage"`	RunningJobs      int     `json:"running_jobs"`	QueuedJobs       int     `json:"queued_jobs"`	IdleWorkers      int     `json:"idle_workers"`	ActiveWorkers    int     `json:"active_workers"`	TotalWorkers     int     `json:"total_workers"`type ResourceStatus struct {}	EstimatedTime   int32  `json:"estimated_time"`	CompletedAt     *int64 `json:"completed_at,omitempty"`	StartedAt       *int64 `json:"started_at,omitempty"`	Progress        float32 `json:"progress"`	Status          string `json:"status"`	Stage           string `json:"stage"`type StageDetail struct {}	StageDetails        []StageDetail        `json:"stage_details"`	EstimatedCompletion int64                `json:"estimated_completion"`	CompletedAt         *int64               `json:"completed_at,omitempty"`	CreatedAt           int64                `json:"created_at"`	ErrorMessage        string               `json:"error_message,omitempty"`	Results             map[string]any       `json:"results,omitempty"`	Progress            float32              `json:"progress"`	CurrentStage        string               `json:"current_stage,omitempty"`	JobIDs              []string             `json:"job_ids"`	Status              string               `json:"status"`	PipelineID          string               `json:"pipeline_id"`type PipelineResponse struct {}	QueuePosition      int32             `json:"queue_position,omitempty"`	EstimatedStartTime int64             `json:"estimated_start_time,omitempty"`	CompletedAt        *int64            `json:"completed_at,omitempty"`	StartedAt          *int64            `json:"started_at,omitempty"`	CreatedAt          int64             `json:"created_at"`	ErrorMessage       string            `json:"error_message,omitempty"`	Result             map[string]string `json:"result,omitempty"`	Progress           float32           `json:"progress,omitempty"`	Priority           int32             `json:"priority"`	JobType            string            `json:"job_type"`	Status             string            `json:"status"`	JobID              string            `json:"job_id"`type JobResponse struct {}	TargetColumns          []string `json:"target_columns"`	EnableAdvancedAnalysis bool     `json:"enable_advanced_analysis"`	NumGPUs                int32    `json:"num_gpus"`	UseMultiGPU            bool     `json:"use_multi_gpu"`	LearningRate           float32  `json:"learning_rate"`	BatchSize              int32    `json:"batch_size"`	NumEpochs              int32    `json:"num_epochs"`type PipelineOptions struct {}	Metadata              map[string]string `json:"metadata"`	Options               PipelineOptions   `json:"options"`	EnableRecommendations bool              `json:"enable_recommendations"`	EnableCollapse        bool              `json:"enable_collapse"`	EnableValidation      bool              `json:"enable_validation"`	Priority              int32             `json:"priority"`	DataFormat            string            `json:"data_format"`	DatasetPath           string            `json:"dataset_path"`	DatasetID             string            `json:"dataset_id"`	UserID                string            `json:"user_id"`type CreateFullPipelineRequest struct {}	Metadata            map[string]string `json:"metadata"`	Options             PipelineOptions   `json:"options"`	Priority            int32             `json:"priority"`	DataFormat          string            `json:"data_format"`	DatasetPath         string            `json:"dataset_path"`	DatasetID           string            `json:"dataset_id"`	UserID              string            `json:"user_id"`type CreateValidationPipelineRequest struct {}	DatasetPath string            `json:"dataset_path,omitempty"`	DatasetID   string            `json:"dataset_id,omitempty"`	Payload     map[string]string `json:"payload"`	Priority    int32             `json:"priority"`	JobType     string            `json:"job_type"`	UserID      string            `json:"user_id"`type CreateJobRequest struct {// Request/Response types}	return nil	// HTTP client doesn't need explicit closingfunc (c *Client) Close() error {// Close closes the client connections}	return &response, nil	}		return nil, fmt.Errorf("failed to get resource status: %w", err)	if err != nil {	err := c.httpClient.Get(ctx, "/api/v1/resources/status", &response)	var response ResourceStatusfunc (c *Client) GetResourceStatus(ctx context.Context) (*ResourceStatus, error) {// GetResourceStatus gets current resource status}	return nil	}		return fmt.Errorf("failed to cancel job: %w", err)	if err != nil {	err := c.httpClient.Post(ctx, fmt.Sprintf("/api/v1/jobs/%s/cancel", jobID), nil, &response)	var response map[string]interface{}func (c *Client) CancelJob(ctx context.Context, jobID string) error {// CancelJob cancels a job}	return &response, nil	}		return nil, fmt.Errorf("failed to get job: %w", err)	if err != nil {	err := c.httpClient.Get(ctx, fmt.Sprintf("/api/v1/jobs/%s", jobID), &response)	var response JobResponsefunc (c *Client) GetJob(ctx context.Context, jobID string) (*JobResponse, error) {// GetJob gets job status}	return &response, nil	}		return nil, fmt.Errorf("failed to create job: %w", err)	if err != nil {	err := c.httpClient.Post(ctx, "/api/v1/jobs", req, &response)	var response JobResponsefunc (c *Client) CreateJob(ctx context.Context, req *CreateJobRequest) (*JobResponse, error) {// CreateJob creates a new job}	return &response, nil	}		return nil, fmt.Errorf("failed to get pipeline status: %w", err)	if err != nil {	err := c.httpClient.Get(ctx, fmt.Sprintf("/api/v1/pipelines/%s", pipelineID), &response)	var response PipelineResponsefunc (c *Client) GetPipelineStatus(ctx context.Context, pipelineID string) (*PipelineResponse, error) {// GetPipelineStatus gets the status of a pipeline}	return &response, nil	}		return nil, fmt.Errorf("failed to create full pipeline: %w", err)	if err != nil {	err := c.httpClient.Post(ctx, "/api/v1/pipelines/full", req, &response)	var response PipelineResponsefunc (c *Client) CreateFullPipeline(ctx context.Context, req *CreateFullPipelineRequest) (*PipelineResponse, error) {// CreateFullPipeline creates a full pipeline with all services}	return &response, nil	}		return nil, fmt.Errorf("failed to create validation pipeline: %w", err)	if err != nil {	err := c.httpClient.Post(ctx, "/api/v1/pipelines/validation", req, &response)	var response PipelineResponsefunc (c *Client) CreateValidationPipeline(ctx context.Context, req *CreateValidationPipelineRequest) (*PipelineResponse, error) {// CreateValidationPipeline creates a validation pipeline}	}, nil		httpClient: httpClient,		baseURL:    baseURL,	return &Client{	httpClient := NewHTTPClient(baseURL, 30*time.Second)	}		baseURL = "http://" + addr	if len(addr) > 0 && addr[0] != 'h' {	baseURL := addr	// Parse address - if it's just host:port, prepend http://func NewClient(addr string) (*Client, error) {// NewClient creates a new orchestrator client}	httpClient *HTTPClient	baseURL    stringtype Client struct {// Client wraps the orchestrator HTTP client)	"google.golang.org/grpc/credentials/insecure"	"google.golang.org/grpc"	"time"	"fmt"	"context"import (package orchestrator