package service
package service




































































































































































































































































































































































































































































}	return stats	}		}			// Successfully parsed		if intVal, err := fmt.Sscanf(val, "%d", &stats[key]); err == nil && intVal == 1 {	for key, val := range result {	}		return stats		log.Printf("Error getting stats: %v", err)	if err != nil {	result, err := jq.redis.HGetAll(ctx, jobStatsKey).Result()	// Get stats from Redis hash	}		"cancelled": 0,		"failed":    0,		"completed": 0,		"running":   0,		"queued":    0,		"total":     0,	stats := map[string]int{	ctx := context.Background()func (jq *JobQueue) GetQueueStats() map[string]int {// GetQueueStats returns queue statistics from Redis}	log.Println("Job queue stopped")	close(jq.stopChan)func (jq *JobQueue) Stop() {// Stop gracefully stops the job queue}	}		jq.UpdateJobStatus(job.ID, StatusCompleted, result, "", 100)		log.Printf("Job %s completed successfully", job.ID)	} else {		}			jq.UpdateJobStatus(job.ID, StatusFailed, nil, err.Error(), 0)		} else {			log.Printf("Job %s queued for retry (%d/%d)", job.ID, job.RetryCount, job.MaxRetries)			})				Member: job.ID,				Score:  float64(job.Priority),			jq.redis.ZAdd(ctx, queueKey, redis.Z{			// Re-add to queue			jq.saveJob(job)			job.Status = StatusQueued			job.RetryCount++		if job.RetryCount < job.MaxRetries {		// Retry logic		log.Printf("Job %s failed: %v", job.ID, err)	if err != nil {	result, err := executor(ctx, job)	// Execute job	jq.UpdateJobStatus(job.ID, StatusRunning, nil, "", 0)	// Update to running	}		return		jq.UpdateJobStatus(job.ID, StatusFailed, nil, "No executor found for job type", 0)		log.Printf("No executor found for job type: %s", job.JobType)	if !exists {	executor, exists := jq.jobCallbacks[job.JobType]	// Get executor	}()		jq.redis.ZRem(ctx, runningKey, job.ID)	defer func() {	// Remove from running set when done	defer cancel()	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)func (jq *JobQueue) executeJob(job *Job) {// executeJob executes a job using the registered executor}	}		}			jq.executeJob(job)			log.Printf("Worker %d processing job %s", id, job.ID)		case job := <-jq.workerChan:			return			log.Printf("Worker %d stopped", id)		case <-jq.stopChan:		select {	for {	log.Printf("Worker %d started", id)func (jq *JobQueue) worker(id int) {// worker processes jobs from the worker channel}	}		}			}				})					Member: jobID,					Score:  float64(job.Priority),				jq.redis.ZAdd(ctx, queueKey, redis.Z{				// Worker channel full, put back in queue			default:				log.Printf("Dispatched job %s to worker", job.ID)			case jq.workerChan <- job:			select {			// Send to worker			})				Member: jobID,				Score:  float64(time.Now().Unix()),			jq.redis.ZAdd(ctx, runningKey, redis.Z{			// Add to running set			}				continue				log.Printf("Error getting job %s: %v", jobID, err)			if err != nil {			job, err := jq.GetJob(jobID)			jobID := result[0].Member.(string)			}				continue				log.Printf("Error popping from queue: %v", err)			if err != nil {			}				continue			if err == redis.Nil || len(result) == 0 {			result, err := jq.redis.ZPopMax(ctx, queueKey, 1).Result()			// Get highest priority job (ZPOPMAX gets highest score)		case <-ticker.C:			return		case <-jq.stopChan:		select {	for {	defer ticker.Stop()	ticker := time.NewTicker(1 * time.Second)	ctx := context.Background()func (jq *JobQueue) processQueue() {// processQueue continuously processes the job queue from Redis}	}		jq.redis.HIncrBy(ctx, jobStatsKey, string(newStatus), 1)	if newStatus != "" {	}		jq.redis.HIncrBy(ctx, jobStatsKey, string(oldStatus), -1)	if oldStatus != "" {	ctx := context.Background()func (jq *JobQueue) updateStats(oldStatus, newStatus JobStatus) {// updateStats updates job statistics}	return jq.redis.Set(ctx, jobKey, jobJSON, 24*time.Hour).Err()	jobKey := fmt.Sprintf("%s%s", jobKeyPrefix, job.ID)	}		return fmt.Errorf("failed to marshal job: %w", err)	if err != nil {	jobJSON, err := json.Marshal(job)	ctx := context.Background()func (jq *JobQueue) saveJob(job *Job) error {// saveJob saves a job to Redis}	return nil	jq.updateStats(oldStatus, status)	// Update stats	}		return err	if err := jq.saveJob(job); err != nil {	// Save to Redis	}		job.CompletedAt = &now		now := time.Now()	if status == StatusCompleted || status == StatusFailed {	}		job.StartedAt = &now		now := time.Now()	if status == StatusRunning && job.StartedAt == nil {	}		job.ErrorMessage = errorMsg	if errorMsg != "" {	}		job.Result = result	if result != nil {	job.Progress = progress	job.Status = status	oldStatus := job.Status	}		return err	if err != nil {	job, err := jq.GetJob(jobID)func (jq *JobQueue) UpdateJobStatus(jobID string, status JobStatus, result map[string]string, errorMsg string, progress float32) error {// UpdateJobStatus updates job status and result in Redis}	return nil	log.Printf("Cancelled job %s", jobID)	jq.updateStats(job.Status, StatusCancelled)	// Update stats	jq.redis.ZRem(ctx, runningKey, jobID)	jq.redis.ZRem(ctx, queueKey, jobID)	// Remove from queue	}		return err	if err := jq.saveJob(job); err != nil {	// Save back to Redis	job.CompletedAt = &now	now := time.Now()	job.Status = StatusCancelled	// Update status	}		return fmt.Errorf("cannot cancel job in status: %s", job.Status)	if job.Status == StatusCompleted || job.Status == StatusFailed {	}		return err	if err != nil {	job, err := jq.GetJob(jobID)	ctx := context.Background()func (jq *JobQueue) CancelJob(jobID string) error {// CancelJob cancels a job}	return jobs[start:end], totalCount, nil	}		end = len(jobs)	if end > len(jobs) {	}		return []*Job{}, totalCount, nil	if start > len(jobs) {	end := start + pageSize	start := (page - 1) * pageSize	// Pagination	totalCount := len(jobs)	})		return jobs[i].CreatedAt.After(jobs[j].CreatedAt)	sort.Slice(jobs, func(i, j int) bool {	// Sort by created date (newest first)	}		}			jobs = append(jobs, job)		if statusFilter == "" || job.Status == statusFilter {		// Apply status filter		}			continue			log.Printf("Warning: failed to get job %s: %v", jobID, err)		if err != nil {		job, err := jq.GetJob(jobID)	for _, jobID := range jobIDs {	jobs := make([]*Job, 0, len(jobIDs))	// Fetch all jobs	}		return nil, 0, fmt.Errorf("failed to get user jobs: %w", err)	if err != nil {	jobIDs, err := jq.redis.SMembers(ctx, userJobsKey).Result()	// Get all job IDs for user	userJobsKey := fmt.Sprintf("%s%s", userJobsPrefix, userID)	ctx := context.Background()func (jq *JobQueue) ListJobs(userID string, statusFilter JobStatus, page, pageSize int) ([]*Job, int, error) {// ListJobs returns jobs for a user with optional status filter}	return &job, nil	}		return nil, fmt.Errorf("failed to unmarshal job: %w", err)	if err := json.Unmarshal([]byte(jobJSON), &job); err != nil {	var job Job	}		return nil, fmt.Errorf("failed to get job: %w", err)	if err != nil {	}		return nil, fmt.Errorf("job not found: %s", jobID)	if err == redis.Nil {	jobJSON, err := jq.redis.Get(ctx, jobKey).Result()	jobKey := fmt.Sprintf("%s%s", jobKeyPrefix, jobID)	ctx := context.Background()func (jq *JobQueue) GetJob(jobID string) (*Job, error) {// GetJob retrieves a job from Redis by ID}	return job, nil	log.Printf("✅ Job created: id=%s, type=%s, priority=%d (Redis)", job.ID, jobType, priority)	jq.redis.HIncrBy(ctx, jobStatsKey, "queued", 1)	jq.redis.HIncrBy(ctx, jobStatsKey, "total", 1)	// Update stats	}		log.Printf("Warning: failed to add job to user list: %v", err)	if err := jq.redis.SAdd(ctx, userJobsKey, job.ID).Err(); err != nil {	userJobsKey := fmt.Sprintf("%s%s", userJobsPrefix, userID)	// Add to user's job list	}		return nil, fmt.Errorf("failed to enqueue job: %w", err)	}).Err(); err != nil {		Member: job.ID,		Score:  float64(priority),	if err := jq.redis.ZAdd(ctx, queueKey, redis.Z{	// Add to priority queue (sorted set by priority)	}		return nil, fmt.Errorf("failed to store job: %w", err)	if err := jq.redis.Set(ctx, jobKey, jobJSON, 24*time.Hour).Err(); err != nil {	jobKey := fmt.Sprintf("%s%s", jobKeyPrefix, job.ID)	// Store job in Redis	}		return nil, fmt.Errorf("failed to marshal job: %w", err)	if err != nil {	jobJSON, err := json.Marshal(job)	// Serialize job	}		MaxRetries: 3,		RetryCount: 0,		CreatedAt:  time.Now(),		Result:     make(map[string]string),		Payload:    payload,		Status:     StatusQueued,		Priority:   priority,		JobType:    jobType,		UserID:     userID,		ID:         uuid.New().String(),	job := &Job{	ctx := context.Background()func (jq *JobQueue) CreateJob(userID, jobType string, priority int32, payload map[string]string) (*Job, error) {// CreateJob creates a new job and adds it to Redis queue}	log.Printf("Registered executor for job type: %s", jobType)	jq.jobCallbacks[jobType] = executorfunc (jq *JobQueue) RegisterExecutor(jobType string, executor JobExecutor) {// RegisterExecutor registers a job executor for a specific job type}	return jq	log.Printf("✅ Job queue initialized with %d workers (Redis-backed)", workers)	go jq.processQueue()	// Start queue processor	}		go jq.worker(i)	for i := 0; i < workers; i++ {	// Start worker pool	}		jobCallbacks: make(map[string]JobExecutor),		workerChan:   make(chan *Job, workers*2),		stopChan:     make(chan struct{}),		workers:      workers,		redis:        redisClient,	jq := &JobQueue{	}		log.Fatal("Redis client is required for job queue")	if redisClient == nil {func NewJobQueue(redisClient *redis.Client, workers int) *JobQueue {// NewJobQueue creates a new job queue with Redis persistence)	jobStatsKey     = "job:stats"	userJobsPrefix  = "user:jobs:"	runningKey      = "job:running"	queueKey        = "job:queue"	jobKeyPrefix    = "job:"const (type JobExecutor func(ctx context.Context, job *Job) (map[string]string, error)// JobExecutor is a function that executes a job}	jobCallbacks map[string]JobExecutor	workerChan   chan *Job	stopChan     chan struct{}	workers      int	redis        *redis.Clienttype JobQueue struct {// JobQueue manages job scheduling and execution with Redis persistence}	MaxRetries   int               `json:"max_retries"`	RetryCount   int               `json:"retry_count"`	CompletedAt  *time.Time        `json:"completed_at,omitempty"`	StartedAt    *time.Time        `json:"started_at,omitempty"`	CreatedAt    time.Time         `json:"created_at"`	Progress     float32           `json:"progress"`	ErrorMessage string            `json:"error_message"`	Result       map[string]string `json:"result"`	Payload      map[string]string `json:"payload"`	Priority     int32             `json:"priority"`	Status       JobStatus         `json:"status"`	JobType      string            `json:"job_type"`	UserID       string            `json:"user_id"`	ID           string            `json:"id"`type Job struct {// Job represents a job in the system)	StatusCancelled JobStatus = "cancelled"	StatusFailed    JobStatus = "failed"	StatusCompleted JobStatus = "completed"	StatusRunning   JobStatus = "running"	StatusQueued    JobStatus = "queued"const (type JobStatus string// JobStatus represents job states)	"github.com/redis/go-redis/v9"	"github.com/google/uuid"	"time"	"sort"	"log"	"fmt"	"encoding/json"	"context"import (