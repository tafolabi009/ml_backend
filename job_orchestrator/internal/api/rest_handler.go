package api
package api

































































































































































































































































































































































































































































}	})		},			Message: message,			Code:    code,		Error: ErrorDetail{	respondJSON(w, status, ErrorResponse{func respondError(w http.ResponseWriter, status int, code, message string) {}	}		log.Printf("Failed to encode response: %v", err)	if err := json.NewEncoder(w).Encode(payload); err != nil {	w.WriteHeader(status)	w.Header().Set("Content-Type", "application/json")func respondJSON(w http.ResponseWriter, status int, payload any) {}	return response	}		response.StageDetails = append(response.StageDetails, detail)		}			detail.CompletedAt = &completedAt			completedAt := stage.CompletedAt.Unix()		if stage.CompletedAt != nil {		}			detail.StartedAt = &startedAt			startedAt := stage.StartedAt.Unix()		if stage.StartedAt != nil {		}			EstimatedTime: stage.EstimatedTime,			Progress:      stage.Progress,			Status:        string(stage.Status),			Stage:         stage.Name,		detail := StageDetail{	for _, stage := range pipeline.Stages {	}		response.CompletedAt = &completedAt		completedAt := pipeline.CompletedAt.Unix()	if pipeline.CompletedAt != nil {	}		StageDetails:       make([]StageDetail, 0, len(pipeline.Stages)),		EstimatedCompletion: pipeline.EstimatedCompletion.Unix(),		CreatedAt:          pipeline.CreatedAt.Unix(),		ErrorMessage:       pipeline.ErrorMessage,		Results:            pipeline.Results,		Progress:           pipeline.Progress,		CurrentStage:       pipeline.CurrentStage,		JobIDs:             pipeline.JobIDs,		Status:             string(pipeline.Status),		PipelineID:         pipeline.ID,	response := PipelineResponse{func (h *RESTHandler) buildPipelineResponse(pipeline *service.Pipeline) PipelineResponse {// Helper methods}	respondJSON(w, http.StatusOK, stats)	stats := h.orchestrator.GetQueueStats()func (h *RESTHandler) GetMetrics(w http.ResponseWriter, r *http.Request) {// GetMetrics returns service metrics}	})		"time":    time.Now().Unix(),		"version": "1.0.0",		"service": "job-orchestrator",		"status":  "healthy",	respondJSON(w, http.StatusOK, map[string]any{func (h *RESTHandler) HealthCheck(w http.ResponseWriter, r *http.Request) {// HealthCheck returns service health status}	})		"message": "Resources allocated successfully",		"success": true,	respondJSON(w, http.StatusOK, map[string]any{	// For now, return success (resource allocation is automatic)	}		return		respondError(w, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req map[string]anyfunc (h *RESTHandler) AllocateResources(w http.ResponseWriter, r *http.Request) {// AllocateResources handles resource allocation requests}	respondJSON(w, http.StatusOK, status)	status := h.orchestrator.GetResourceStatus(r.Context())func (h *RESTHandler) GetResourceStatus(w http.ResponseWriter, r *http.Request) {// GetResourceStatus returns current resource utilization}	respondJSON(w, http.StatusOK, response)	response := h.buildPipelineResponse(pipeline)	}		return		respondError(w, http.StatusNotFound, "PIPELINE_NOT_FOUND", "Pipeline not found")	if err != nil {	pipeline, err := h.orchestrator.GetPipeline(r.Context(), pipelineID)	pipelineID := vars["pipeline_id"]	vars := mux.Vars(r)func (h *RESTHandler) GetPipelineStatus(w http.ResponseWriter, r *http.Request) {// GetPipelineStatus retrieves pipeline status}	respondJSON(w, http.StatusCreated, response)	response := h.buildPipelineResponse(pipeline)	}		return		respondError(w, http.StatusInternalServerError, "PIPELINE_CREATION_FAILED", err.Error())		log.Printf("Failed to create full pipeline: %v", err)	if err != nil {	pipeline, err := h.orchestrator.CreateFullPipeline(r.Context(), req)	// Create full pipeline	}		return		respondError(w, http.StatusBadRequest, "MISSING_FIELDS", "Required fields missing")	if req.UserID == "" || req.DatasetID == "" || req.DatasetPath == "" {	// Validate required fields	}		return		respondError(w, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateFullPipelineRequestfunc (h *RESTHandler) CreateFullPipeline(w http.ResponseWriter, r *http.Request) {// CreateFullPipeline creates a full validation + collapse detection pipeline}	respondJSON(w, http.StatusCreated, response)	response := h.buildPipelineResponse(pipeline)	}		return		respondError(w, http.StatusInternalServerError, "PIPELINE_CREATION_FAILED", err.Error())		log.Printf("Failed to create validation pipeline: %v", err)	if err != nil {	pipeline, err := h.orchestrator.CreateValidationPipeline(r.Context(), req)	// Create validation pipeline	}		return		respondError(w, http.StatusBadRequest, "MISSING_FIELDS", "Required fields missing")	if req.UserID == "" || req.DatasetID == "" || req.DatasetPath == "" {	// Validate required fields	}		return		respondError(w, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateValidationPipelineRequestfunc (h *RESTHandler) CreateValidationPipeline(w http.ResponseWriter, r *http.Request) {// CreateValidationPipeline creates a validation-only pipeline}	respondJSON(w, http.StatusOK, response)	}		"page_size":   pageSize,		"page":        page,		"total_count": totalCount,		"jobs":        jobResponses,	response := map[string]any{	}		jobResponses = append(jobResponses, jr)		}			jr.CompletedAt = &completedAt			completedAt := job.CompletedAt.Unix()		if job.CompletedAt != nil {		}			jr.StartedAt = &startedAt			startedAt := job.StartedAt.Unix()		if job.StartedAt != nil {		}			CreatedAt: job.CreatedAt.Unix(),			Progress:  job.Progress,			Priority:  job.Priority,			JobType:   job.JobType,			Status:    string(job.Status),			JobID:     job.ID,		jr := JobResponse{	for _, job := range jobs {	jobResponses := make([]JobResponse, 0, len(jobs))	jobs, totalCount := h.orchestrator.ListJobs(r.Context(), userID, service.JobStatus(status), page, pageSize)	}		pageSize = 20	if pageSize < 1 || pageSize > 100 {	pageSize, _ := strconv.Atoi(r.URL.Query().Get("page_size"))	}		page = 1	if page < 1 {	page, _ := strconv.Atoi(r.URL.Query().Get("page"))	status := r.URL.Query().Get("status")	userID := r.URL.Query().Get("user_id")func (h *RESTHandler) ListJobs(w http.ResponseWriter, r *http.Request) {// ListJobs lists jobs with filtering}	})		"message": "Job cancelled successfully",		"success": true,	respondJSON(w, http.StatusOK, map[string]any{	}		return		respondError(w, http.StatusBadRequest, "CANCEL_FAILED", err.Error())	if err != nil {	err := h.orchestrator.CancelJob(r.Context(), jobID, "User requested cancellation")	jobID := vars["job_id"]	vars := mux.Vars(r)func (h *RESTHandler) CancelJob(w http.ResponseWriter, r *http.Request) {// CancelJob cancels a running or queued job}	respondJSON(w, http.StatusOK, response)	}		response.CompletedAt = &completedAt		completedAt := job.CompletedAt.Unix()	if job.CompletedAt != nil {	}		response.StartedAt = &startedAt		startedAt := job.StartedAt.Unix()	if job.StartedAt != nil {	}		CreatedAt:    job.CreatedAt.Unix(),		ErrorMessage: job.ErrorMessage,		Result:       job.Result,		Progress:     job.Progress,		Priority:     job.Priority,		JobType:      job.JobType,		Status:       string(job.Status),		JobID:        job.ID,	response := JobResponse{	}		return		respondError(w, http.StatusNotFound, "JOB_NOT_FOUND", "Job not found")	if err != nil {	job, err := h.orchestrator.GetJob(r.Context(), jobID)	jobID := vars["job_id"]	vars := mux.Vars(r)func (h *RESTHandler) GetJob(w http.ResponseWriter, r *http.Request) {// GetJob retrieves job status}	respondJSON(w, http.StatusCreated, response)	}		QueuePosition:      int32(queuePos),		EstimatedStartTime: job.CreatedAt.Unix() + int64(queuePos*60),		CreatedAt:          job.CreatedAt.Unix(),		Priority:           job.Priority,		JobType:            job.JobType,		Status:             string(job.Status),		JobID:              job.ID,	response := JobResponse{	}		return		respondError(w, http.StatusInternalServerError, "JOB_CREATION_FAILED", err.Error())		log.Printf("Failed to create job: %v", err)	if err != nil {	job, queuePos, err := h.orchestrator.CreateJob(r.Context(), req.UserID, req.JobType, req.Priority, req.Payload)	// Create job through orchestrator	}		return		respondError(w, http.StatusBadRequest, "MISSING_FIELDS", "user_id and job_type are required")	if req.UserID == "" || req.JobType == "" {	// Validate request	}		return		respondError(w, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {	var req CreateJobRequestfunc (h *RESTHandler) CreateJob(w http.ResponseWriter, r *http.Request) {// CreateJob handles job creation requests}	Message string `json:"message"`	Code    string `json:"code"`type ErrorDetail struct {}	Error ErrorDetail `json:"error"`type ErrorResponse struct {}	TotalJobsToday   int     `json:"total_jobs_today"`	GPUInUse         int     `json:"gpu_in_use"`	GPUAvailable     int     `json:"gpu_available"`	MemoryUsage      float64 `json:"memory_usage"`	CPUUsage         float64 `json:"cpu_usage"`	RunningJobs      int     `json:"running_jobs"`	QueuedJobs       int     `json:"queued_jobs"`	IdleWorkers      int     `json:"idle_workers"`	ActiveWorkers    int     `json:"active_workers"`	TotalWorkers     int     `json:"total_workers"`type ResourceStatus struct {}	EstimatedTime   int32  `json:"estimated_time"`	CompletedAt     *int64 `json:"completed_at,omitempty"`	StartedAt       *int64 `json:"started_at,omitempty"`	Progress        float32 `json:"progress"`	Status          string `json:"status"`	Stage           string `json:"stage"`type StageDetail struct {}	StageDetails       []StageDetail        `json:"stage_details"`	EstimatedCompletion int64               `json:"estimated_completion"`	CompletedAt        *int64               `json:"completed_at,omitempty"`	CreatedAt          int64                `json:"created_at"`	ErrorMessage       string               `json:"error_message,omitempty"`	Results            map[string]any       `json:"results,omitempty"`	Progress           float32              `json:"progress"`	CurrentStage       string               `json:"current_stage,omitempty"`	JobIDs             []string             `json:"job_ids"`	Status             string               `json:"status"`	PipelineID         string               `json:"pipeline_id"`type PipelineResponse struct {}	QueuePosition      int32             `json:"queue_position,omitempty"`	EstimatedStartTime int64             `json:"estimated_start_time,omitempty"`	CompletedAt        *int64            `json:"completed_at,omitempty"`	StartedAt          *int64            `json:"started_at,omitempty"`	CreatedAt          int64             `json:"created_at"`	ErrorMessage       string            `json:"error_message,omitempty"`	Result             map[string]string `json:"result,omitempty"`	Progress           float32           `json:"progress,omitempty"`	Priority           int32             `json:"priority"`	JobType            string            `json:"job_type"`	Status             string            `json:"status"`	JobID              string            `json:"job_id"`type JobResponse struct {}	TargetColumns          []string `json:"target_columns"`	EnableAdvancedAnalysis bool     `json:"enable_advanced_analysis"`	NumGPUs                int32    `json:"num_gpus"`	UseMultiGPU            bool     `json:"use_multi_gpu"`	LearningRate           float32  `json:"learning_rate"`	BatchSize              int32    `json:"batch_size"`	NumEpochs              int32    `json:"num_epochs"`type PipelineOptions struct {}	Metadata            map[string]string `json:"metadata"`	Options             PipelineOptions   `json:"options"`	EnableRecommendations bool            `json:"enable_recommendations"`	EnableCollapse      bool              `json:"enable_collapse"`	EnableValidation    bool              `json:"enable_validation"`	Priority            int32             `json:"priority"`	DataFormat          string            `json:"data_format"`	DatasetPath         string            `json:"dataset_path"`	DatasetID           string            `json:"dataset_id"`	UserID              string            `json:"user_id"`type CreateFullPipelineRequest struct {}	Metadata            map[string]string `json:"metadata"`	Options             PipelineOptions   `json:"options"`	Priority            int32             `json:"priority"`	DataFormat          string            `json:"data_format"`	DatasetPath         string            `json:"dataset_path"`	DatasetID           string            `json:"dataset_id"`	UserID              string            `json:"user_id"`type CreateValidationPipelineRequest struct {}	DatasetPath string            `json:"dataset_path,omitempty"`	DatasetID   string            `json:"dataset_id,omitempty"`	Payload     map[string]string `json:"payload"`	Priority    int32             `json:"priority"`	JobType     string            `json:"job_type"`	UserID      string            `json:"user_id"`type CreateJobRequest struct {// Request/Response types}	router.HandleFunc("/metrics", h.GetMetrics).Methods("GET")	router.HandleFunc("/health", h.HealthCheck).Methods("GET")	// Health check		router.HandleFunc("/api/v1/resources/allocate", h.AllocateResources).Methods("POST")	router.HandleFunc("/api/v1/resources/status", h.GetResourceStatus).Methods("GET")	// Resource management endpoints		router.HandleFunc("/api/v1/pipelines/{pipeline_id}", h.GetPipelineStatus).Methods("GET")	router.HandleFunc("/api/v1/pipelines/full", h.CreateFullPipeline).Methods("POST")	router.HandleFunc("/api/v1/pipelines/validation", h.CreateValidationPipeline).Methods("POST")	// Pipeline orchestration endpoints		router.HandleFunc("/api/v1/jobs", h.ListJobs).Methods("GET")	router.HandleFunc("/api/v1/jobs/{job_id}/cancel", h.CancelJob).Methods("POST")	router.HandleFunc("/api/v1/jobs/{job_id}", h.GetJob).Methods("GET")	router.HandleFunc("/api/v1/jobs", h.CreateJob).Methods("POST")	// Job management endpointsfunc (h *RESTHandler) SetupRoutes(router *mux.Router) {// SetupRoutes configures HTTP routes}	}		orchestrator: orchestrator,	return &RESTHandler{func NewRESTHandler(orchestrator *service.OrchestratorService) *RESTHandler {// NewRESTHandler creates a new REST API handler}	orchestrator *service.OrchestratorServicetype RESTHandler struct {// RESTHandler handles REST API requests from Go backend)	"github.com/tafolabi009/backend/job_orchestrator/internal/service"	"github.com/gorilla/mux"	"time"	"strconv"	"net/http"	"log"	"encoding/json"import (