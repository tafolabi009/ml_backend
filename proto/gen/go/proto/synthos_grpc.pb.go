// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: proto/synthos.proto

package synthos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ValidationEngineClient is the client API for ValidationEngine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ValidationEngineClient interface {
	// Phase 2: Analyze diversity and create stratified sample
	AnalyzeDiversity(ctx context.Context, in *DiversityRequest, opts ...grpc.CallOption) (*DiversityResponse, error)
	// Phase 3: Pre-screen against collapse signature library
	PreScreenRisk(ctx context.Context, in *PreScreenRequest, opts ...grpc.CallOption) (*PreScreenResponse, error)
	// Phase 4: Multi-scale cascade training (STREAMING every 10s)
	TrainCascade(ctx context.Context, in *CascadeRequest, opts ...grpc.CallOption) (ValidationEngine_TrainCascadeClient, error)
	// Phase 5: Get final predictions with confidence intervals
	GetPredictions(ctx context.Context, in *PredictionRequest, opts ...grpc.CallOption) (*PredictionResponse, error)
}

type validationEngineClient struct {
	cc grpc.ClientConnInterface
}

func NewValidationEngineClient(cc grpc.ClientConnInterface) ValidationEngineClient {
	return &validationEngineClient{cc}
}

func (c *validationEngineClient) AnalyzeDiversity(ctx context.Context, in *DiversityRequest, opts ...grpc.CallOption) (*DiversityResponse, error) {
	out := new(DiversityResponse)
	err := c.cc.Invoke(ctx, "/synthos.ValidationEngine/AnalyzeDiversity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationEngineClient) PreScreenRisk(ctx context.Context, in *PreScreenRequest, opts ...grpc.CallOption) (*PreScreenResponse, error) {
	out := new(PreScreenResponse)
	err := c.cc.Invoke(ctx, "/synthos.ValidationEngine/PreScreenRisk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *validationEngineClient) TrainCascade(ctx context.Context, in *CascadeRequest, opts ...grpc.CallOption) (ValidationEngine_TrainCascadeClient, error) {
	stream, err := c.cc.NewStream(ctx, &ValidationEngine_ServiceDesc.Streams[0], "/synthos.ValidationEngine/TrainCascade", opts...)
	if err != nil {
		return nil, err
	}
	x := &validationEngineTrainCascadeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ValidationEngine_TrainCascadeClient interface {
	Recv() (*CascadeProgress, error)
	grpc.ClientStream
}

type validationEngineTrainCascadeClient struct {
	grpc.ClientStream
}

func (x *validationEngineTrainCascadeClient) Recv() (*CascadeProgress, error) {
	m := new(CascadeProgress)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *validationEngineClient) GetPredictions(ctx context.Context, in *PredictionRequest, opts ...grpc.CallOption) (*PredictionResponse, error) {
	out := new(PredictionResponse)
	err := c.cc.Invoke(ctx, "/synthos.ValidationEngine/GetPredictions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ValidationEngineServer is the server API for ValidationEngine service.
// All implementations should embed UnimplementedValidationEngineServer
// for forward compatibility
type ValidationEngineServer interface {
	// Phase 2: Analyze diversity and create stratified sample
	AnalyzeDiversity(context.Context, *DiversityRequest) (*DiversityResponse, error)
	// Phase 3: Pre-screen against collapse signature library
	PreScreenRisk(context.Context, *PreScreenRequest) (*PreScreenResponse, error)
	// Phase 4: Multi-scale cascade training (STREAMING every 10s)
	TrainCascade(*CascadeRequest, ValidationEngine_TrainCascadeServer) error
	// Phase 5: Get final predictions with confidence intervals
	GetPredictions(context.Context, *PredictionRequest) (*PredictionResponse, error)
}

// UnimplementedValidationEngineServer should be embedded to have forward compatible implementations.
type UnimplementedValidationEngineServer struct {
}

func (UnimplementedValidationEngineServer) AnalyzeDiversity(context.Context, *DiversityRequest) (*DiversityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeDiversity not implemented")
}
func (UnimplementedValidationEngineServer) PreScreenRisk(context.Context, *PreScreenRequest) (*PreScreenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreScreenRisk not implemented")
}
func (UnimplementedValidationEngineServer) TrainCascade(*CascadeRequest, ValidationEngine_TrainCascadeServer) error {
	return status.Errorf(codes.Unimplemented, "method TrainCascade not implemented")
}
func (UnimplementedValidationEngineServer) GetPredictions(context.Context, *PredictionRequest) (*PredictionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPredictions not implemented")
}

// UnsafeValidationEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ValidationEngineServer will
// result in compilation errors.
type UnsafeValidationEngineServer interface {
	mustEmbedUnimplementedValidationEngineServer()
}

func RegisterValidationEngineServer(s grpc.ServiceRegistrar, srv ValidationEngineServer) {
	s.RegisterService(&ValidationEngine_ServiceDesc, srv)
}

func _ValidationEngine_AnalyzeDiversity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiversityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationEngineServer).AnalyzeDiversity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synthos.ValidationEngine/AnalyzeDiversity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationEngineServer).AnalyzeDiversity(ctx, req.(*DiversityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidationEngine_PreScreenRisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreScreenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationEngineServer).PreScreenRisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synthos.ValidationEngine/PreScreenRisk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationEngineServer).PreScreenRisk(ctx, req.(*PreScreenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ValidationEngine_TrainCascade_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CascadeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ValidationEngineServer).TrainCascade(m, &validationEngineTrainCascadeServer{stream})
}

type ValidationEngine_TrainCascadeServer interface {
	Send(*CascadeProgress) error
	grpc.ServerStream
}

type validationEngineTrainCascadeServer struct {
	grpc.ServerStream
}

func (x *validationEngineTrainCascadeServer) Send(m *CascadeProgress) error {
	return x.ServerStream.SendMsg(m)
}

func _ValidationEngine_GetPredictions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PredictionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ValidationEngineServer).GetPredictions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synthos.ValidationEngine/GetPredictions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ValidationEngineServer).GetPredictions(ctx, req.(*PredictionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ValidationEngine_ServiceDesc is the grpc.ServiceDesc for ValidationEngine service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ValidationEngine_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "synthos.ValidationEngine",
	HandlerType: (*ValidationEngineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnalyzeDiversity",
			Handler:    _ValidationEngine_AnalyzeDiversity_Handler,
		},
		{
			MethodName: "PreScreenRisk",
			Handler:    _ValidationEngine_PreScreenRisk_Handler,
		},
		{
			MethodName: "GetPredictions",
			Handler:    _ValidationEngine_GetPredictions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TrainCascade",
			Handler:       _ValidationEngine_TrainCascade_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/synthos.proto",
}

// CollapseEngineClient is the client API for CollapseEngine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CollapseEngineClient interface {
	// Phase 5: Detect collapse in cascade results
	DetectCollapse(ctx context.Context, in *CollapseRequest, opts ...grpc.CallOption) (*CollapseResponse, error)
	// Phase 6: Pinpoint problematic data regions
	LocalizeProblems(ctx context.Context, in *LocalizationRequest, opts ...grpc.CallOption) (*LocalizationResponse, error)
	// Phase 6: Generate actionable recommendations
	GenerateRecommendations(ctx context.Context, in *RecommendationRequest, opts ...grpc.CallOption) (*RecommendationResponse, error)
}

type collapseEngineClient struct {
	cc grpc.ClientConnInterface
}

func NewCollapseEngineClient(cc grpc.ClientConnInterface) CollapseEngineClient {
	return &collapseEngineClient{cc}
}

func (c *collapseEngineClient) DetectCollapse(ctx context.Context, in *CollapseRequest, opts ...grpc.CallOption) (*CollapseResponse, error) {
	out := new(CollapseResponse)
	err := c.cc.Invoke(ctx, "/synthos.CollapseEngine/DetectCollapse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collapseEngineClient) LocalizeProblems(ctx context.Context, in *LocalizationRequest, opts ...grpc.CallOption) (*LocalizationResponse, error) {
	out := new(LocalizationResponse)
	err := c.cc.Invoke(ctx, "/synthos.CollapseEngine/LocalizeProblems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *collapseEngineClient) GenerateRecommendations(ctx context.Context, in *RecommendationRequest, opts ...grpc.CallOption) (*RecommendationResponse, error) {
	out := new(RecommendationResponse)
	err := c.cc.Invoke(ctx, "/synthos.CollapseEngine/GenerateRecommendations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CollapseEngineServer is the server API for CollapseEngine service.
// All implementations should embed UnimplementedCollapseEngineServer
// for forward compatibility
type CollapseEngineServer interface {
	// Phase 5: Detect collapse in cascade results
	DetectCollapse(context.Context, *CollapseRequest) (*CollapseResponse, error)
	// Phase 6: Pinpoint problematic data regions
	LocalizeProblems(context.Context, *LocalizationRequest) (*LocalizationResponse, error)
	// Phase 6: Generate actionable recommendations
	GenerateRecommendations(context.Context, *RecommendationRequest) (*RecommendationResponse, error)
}

// UnimplementedCollapseEngineServer should be embedded to have forward compatible implementations.
type UnimplementedCollapseEngineServer struct {
}

func (UnimplementedCollapseEngineServer) DetectCollapse(context.Context, *CollapseRequest) (*CollapseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectCollapse not implemented")
}
func (UnimplementedCollapseEngineServer) LocalizeProblems(context.Context, *LocalizationRequest) (*LocalizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalizeProblems not implemented")
}
func (UnimplementedCollapseEngineServer) GenerateRecommendations(context.Context, *RecommendationRequest) (*RecommendationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRecommendations not implemented")
}

// UnsafeCollapseEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CollapseEngineServer will
// result in compilation errors.
type UnsafeCollapseEngineServer interface {
	mustEmbedUnimplementedCollapseEngineServer()
}

func RegisterCollapseEngineServer(s grpc.ServiceRegistrar, srv CollapseEngineServer) {
	s.RegisterService(&CollapseEngine_ServiceDesc, srv)
}

func _CollapseEngine_DetectCollapse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollapseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollapseEngineServer).DetectCollapse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synthos.CollapseEngine/DetectCollapse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollapseEngineServer).DetectCollapse(ctx, req.(*CollapseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollapseEngine_LocalizeProblems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocalizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollapseEngineServer).LocalizeProblems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synthos.CollapseEngine/LocalizeProblems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollapseEngineServer).LocalizeProblems(ctx, req.(*LocalizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CollapseEngine_GenerateRecommendations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecommendationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CollapseEngineServer).GenerateRecommendations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/synthos.CollapseEngine/GenerateRecommendations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CollapseEngineServer).GenerateRecommendations(ctx, req.(*RecommendationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CollapseEngine_ServiceDesc is the grpc.ServiceDesc for CollapseEngine service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CollapseEngine_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "synthos.CollapseEngine",
	HandlerType: (*CollapseEngineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DetectCollapse",
			Handler:    _CollapseEngine_DetectCollapse_Handler,
		},
		{
			MethodName: "LocalizeProblems",
			Handler:    _CollapseEngine_LocalizeProblems_Handler,
		},
		{
			MethodName: "GenerateRecommendations",
			Handler:    _CollapseEngine_GenerateRecommendations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/synthos.proto",
}
